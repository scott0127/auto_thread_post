<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>筆記應用 - Threads 發布</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css"
    />
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
  </head>
  <body>
    <div class="page-container">
      <!-- 左側：筆記功能 -->
      <div class="container">
        <h1><i class="fas fa-feather-alt"></i> 筆記應用</h1>
        <form method="POST" action="/publish" id="noteForm">
          <div class="form-group">
            <div class="textarea-wrapper">
              <textarea
                id="noteInput"
                name="note"
                placeholder="在此輸入英文單字，自動提供中文翻譯..."
                oninput="updateCharCount()"
              ></textarea>
              <div id="aiSuggestion" class="ai-suggestion"></div>
            </div>
            <p id="charCount">0/500</p>
            <p class="input-hint">
              提示：輸入文字(至少3個字母)，按下 Tab 鍵接受補全建議
            </p>
          </div>
          <div class="buttons">
            <button type="button" id="publishButton">
              <i class="fas fa-paper-plane"></i> 發布到 Threads
            </button>
          </div>
        </form>
        <div id="statusMessage"></div>

        <!-- 替換 saved-notes div -->
        <div class="saved-notes">
          <h2><i class="fas fa-history"></i> 已保存的筆記</h2>
          <div id="notesList" class="notes-container">
            <!-- 筆記卡片將在這裡動態生成 -->
          </div>
        </div>
      </div>

      <!-- 右側：AI 問答工具 -->
      <div class="ai-assistant-container">
        <div class="ai-assistant-header">
          <h2><i class="fas fa-robot"></i> AI 助手</h2>
          <p class="assistant-subtitle">提問任何問題，獲得即時回答</p>
        </div>
        <div class="chat-container">
          <div id="chatMessages" class="chat-messages">
            <div class="message system-message">
              <div class="message-content">
                <p>您好！我是您的 AI 助手，有什麼我能幫您解答的嗎？</p>
              </div>
            </div>
          </div>
          <form id="questionForm" class="question-form">
            <div class="question-input-area">
              <textarea
                id="questionInput"
                placeholder="輸入您的問題..."
                rows="3"
              ></textarea>
              <button type="submit" id="sendQuestion">
                <i class="fas fa-paper-plane"></i>
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>

    <script>
      let saveTimeout;

      // 監聽文字框的輸入事件
      document
        .getElementById("noteInput")
        .addEventListener("input", function () {
          const note = this.value;

          // 防止頻繁保存，設定延遲保存
          clearTimeout(saveTimeout);
          saveTimeout = setTimeout(() => {
            saveNoteToServer(note);
          }, 800); // 延遲 800 毫秒保存
        });

      // 發佈按鈕
      document
        .getElementById("publishButton")
        .addEventListener("click", function (e) {
          e.preventDefault();
          const note = document.getElementById("noteInput").value;
          const user = document.getElementById("user").value;

          if (!note.trim()) {
            showStatusMessage("請輸入筆記內容", "error");
            return;
          }

          publishNote(note, user);
        });

      // 更新字元計數
      function updateCharCount() {
        const noteInput = document.getElementById("noteInput");
        const charCount = document.getElementById("charCount");

        const text = noteInput.value;
        const length = text.length;

        charCount.textContent = `${length}/500`;

        if (length > 500) {
          charCount.style.color = "#e74c3c";
        } else {
          charCount.style.color = "#7f8c8d";
        }
      }

      // 將筆記保存到伺服器
      function saveNoteToServer(note) {
        if (!note.trim()) return;

        fetch("/", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: `note=${encodeURIComponent(note)}`,
        })
          .then((response) => response.text())
          .then(() => {
            showStatusMessage("筆記已自動保存", "success");
            fetchNotes(); // 保存後立即更新筆記列表
          })
          .catch((error) => {
            showStatusMessage("保存筆記時發生錯誤", "error");
            console.error("Error:", error);
          });
      }

      // 發布筆記到 Threads
      function publishNote(note, user) {
        fetch("/publish", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: `note=${encodeURIComponent(note)}&user=${user}`,
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.error) {
              showStatusMessage(data.error, "error");
            } else {
              showStatusMessage("筆記已成功發布到 Threads!", "success");
              fetchNotes();
            }
          })
          .catch((error) => {
            showStatusMessage("發布筆記時發生錯誤", "error");
            console.error("Error:", error);
          });
      }

      // 顯示狀態訊息
      function showStatusMessage(message, type) {
        const statusMessage = document.getElementById("statusMessage");
        statusMessage.textContent = message;
        statusMessage.className = type;
        statusMessage.classList.add("show");

        setTimeout(() => {
          statusMessage.classList.remove("show");
        }, 3000);
      }

      // 在 script 標籤中替換 fetchNotes 函數

      // 讀取筆記列表
      function fetchNotes() {
        fetch("/notes")
          .then((response) => response.json())
          .then((data) => {
            const notesList = document.getElementById("notesList");
            notesList.innerHTML = ""; // 清空現有列表

            if (data.notes.length === 0) {
              notesList.innerHTML =
                '<div class="no-notes"><i class="fas fa-sticky-note"></i> 還沒有保存的筆記</div>';
              return;
            }

            // 根據時間分類筆記
            const notesGroups = {};
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            const todayStr = formatDate(today);
            const yesterdayStr = formatDate(yesterday);

            data.notes.forEach((note, index) => {
              // 建立卡片容器
              const card = document.createElement("div");
              card.className = "note-card";

              // 拆分內容，找出第一行作為日期標題
              const lines = note.split("\n");
              const firstLine = lines[0];
              let dateStr = "未知日期";
              let timeStr = "";
              let content = note;

              // 解析日期和時間
              if (
                firstLine &&
                firstLine.match(/^\d{4}[-\/]\d{1,2}[-\/]\d{1,2}/)
              ) {
                dateStr = firstLine;

                // 檢查是否有時間資訊
                const timeParts = dateStr.match(/\d{1,2}:\d{1,2}/);
                if (timeParts) {
                  timeStr = timeParts[0];
                }

                content = lines.slice(1).join("\n");
              }

              // 添加版本標籤
              const versionSpan = document.createElement("span");
              versionSpan.className = "note-version";
              versionSpan.textContent = `#${index + 1}`;
              card.appendChild(versionSpan);

              // 添加日期標題
              const dateSpan = document.createElement("div");
              dateSpan.className = "note-date";

              // 確定日期顯示文字
              let dateDisplay = dateStr;
              if (dateStr.includes(todayStr)) {
                dateDisplay = "今天";
              } else if (dateStr.includes(yesterdayStr)) {
                dateDisplay = "昨天";
              }

              if (timeStr) {
                dateSpan.innerHTML = `${dateDisplay} <span class="note-time">${timeStr}</span>`;
              } else {
                dateSpan.textContent = dateDisplay;
              }
              card.appendChild(dateSpan);

              // 添加筆記內容
              const paragraph = document.createElement("p");
              paragraph.innerHTML = content.replace(/\n/g, "<br>");
              card.appendChild(paragraph);

              // 添加卡片頁腳 (可選)
              const footer = document.createElement("div");
              footer.className = "note-card-footer";

              const charCount = content.length;
              footer.textContent = `${charCount} 個字元`;

              card.appendChild(footer);

              // 將卡片加入列表
              notesList.appendChild(card);
            });
          })
          .catch((error) => {
            console.error("Error fetching notes:", error);
            showStatusMessage("讀取筆記失敗", "error");
          });
      }
      // 在現有 script 標籤內部，fetchNotes() 函數後面添加以下代碼

      // AI 補全相關變數
      let aiSuggestionTimeout;
      let currentAISuggestion = "";
      let suggestionVisible = false;
      let isRequestPending = false;
      const debounceDelay = 500; // 等待用戶停止輸入 500ms 后才發送請求

      // 監聽輸入事件，觸發 AI 補全
      document
        .getElementById("noteInput")
        .addEventListener("input", function () {
          const note = this.value;

          // 更新字數計數
          updateCharCount();

          // 處理 AI 補全
          handleAICompletion(this);

          // 防止頻繁保存，設定延遲保存
          clearTimeout(saveTimeout);
          saveTimeout = setTimeout(() => {
            saveNoteToServer(note);
          }, 800); // 延遲 800 毫秒保存
        });

      // 新增處理 AI 補全的函數
      function handleAICompletion(textarea) {
        // 獲取當前文本和光標位置
        const text = textarea.value;
        const cursorPos = textarea.selectionStart;

        // 如果光標不在文本末尾，不提供建議
        if (cursorPos !== text.length) {
          clearAISuggestion();
          return;
        }

        // 如果文本太短，不提供建議
        if (text.trim().length < 2) {
          clearAISuggestion();
          return;
        }

        // 防抖動，避免頻繁請求
        clearTimeout(aiSuggestionTimeout);
        aiSuggestionTimeout = setTimeout(() => {
          // 避免重複請求
          if (!isRequestPending) {
            requestAICompletion(text);
          }
        }, debounceDelay);
      }

      // 請求 AI 補全
      function requestAICompletion(text) {
        isRequestPending = true;

        // 顯示等待提示
        showAITypingIndicator();

        // 發送請求到後端 AI API
        fetch("/ai-complete", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ text: text }),
        })
          .then((response) => response.json())
          .then((data) => {
            isRequestPending = false;

            if (data.completion) {
              // 顯示 AI 建議
              showAISuggestion(text, data.completion);
            } else {
              clearAISuggestion();
            }
          })
          .catch((error) => {
            console.error("AI 補全請求錯誤:", error);
            isRequestPending = false;
            clearAISuggestion();
          });
      }

      // 顯示 AI 正在輸入的指示器
      function showAITypingIndicator() {
        const aiSuggestionElement = document.getElementById("aiSuggestion");
        const noteInput = document.getElementById("noteInput");
        const text = noteInput.value;

        aiSuggestionElement.innerHTML = escapeHtml(text);
      }

      // 徹底重寫的顯示建議方法

      // 顯示 AI 建議
      function showAISuggestion(originalText, completion) {
        // 獲取 noteInput 相關信息
        const noteInput = document.getElementById("noteInput");
        const textarea = noteInput;
        const text = textarea.value;

        // 如果沒有有效的補全，清除建議
        if (!completion || completion.length <= originalText.length) {
          clearAISuggestion();
          return;
        }

        // 提取建議部分
        const suggestion = completion.substring(originalText.length);

        // 獲取光標位置信息
        const cursorPos = textarea.selectionEnd;

        // 儲存當前建議
        currentAISuggestion = suggestion;
        suggestionVisible = true;

        // 獲取或創建浮動提示元素
        let hintElem = document.getElementById("floating-hint");
        if (!hintElem) {
          hintElem = document.createElement("div");
          hintElem.id = "floating-hint";
          hintElem.style.position = "absolute";
          hintElem.style.zIndex = "1000";
          hintElem.style.pointerEvents = "none";
          hintElem.style.backgroundColor = "transparent";
          hintElem.style.fontFamily = getComputedStyle(textarea).fontFamily;
          hintElem.style.fontSize = getComputedStyle(textarea).fontSize;
          hintElem.style.whiteSpace = "pre";
          document.body.appendChild(hintElem);
        }

        // 獲取 textarea 的位置
        const rect = textarea.getBoundingClientRect();

        // 創建一個臨時的隱藏元素來計算確切位置
        const temp = document.createElement("div");
        temp.style.position = "absolute";
        temp.style.visibility = "hidden";
        temp.style.whiteSpace = "pre-wrap";
        temp.style.wordWrap = "break-word";
        temp.style.overflow = "hidden";
        temp.style.width = textarea.clientWidth - 30 + "px"; // 減去 padding
        temp.style.height = "auto";
        temp.style.fontFamily = getComputedStyle(textarea).fontFamily;
        temp.style.fontSize = getComputedStyle(textarea).fontSize;
        temp.style.lineHeight = getComputedStyle(textarea).lineHeight;

        // 獲取光標前的文本
        const beforeCursor = text.substring(0, cursorPos);
        temp.textContent = beforeCursor;

        document.body.appendChild(temp);

        // 計算光標位置
        const lastLine = beforeCursor.split("\n").pop();

        // 獲取元素的偏移信息
        const textWidth = getTextWidth(lastLine, textarea);

        // 清理臨時元素
        document.body.removeChild(temp);

        // 根據光標位置設置提示元素位置
        const paddingLeft = parseInt(getComputedStyle(textarea).paddingLeft);
        const paddingTop = parseInt(getComputedStyle(textarea).paddingTop);
        const lineHeight = parseInt(getComputedStyle(textarea).lineHeight);

        // 計算行數
        const lines = beforeCursor.split("\n").length;

        // 設置提示元素位置
        hintElem.style.left =
          rect.left + textWidth + paddingLeft + window.scrollX + "px";
        hintElem.style.top =
          rect.top +
          (lines - 1) * lineHeight +
          paddingTop +
          window.scrollY +
          "px";

        // 設置提示內容
        hintElem.innerHTML = formatWordSuggestion(suggestion);
        hintElem.style.color = "#aaaaaa";
      }

      // 清除 AI 建議
      function clearAISuggestion() {
        const hintElem = document.getElementById("floating-hint");
        if (hintElem) {
          hintElem.innerHTML = "";
        }
        currentAISuggestion = "";
        suggestionVisible = false;
      }
      // 添加 AI 問答功能的腳本
      document.getElementById('questionForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const questionInput = document.getElementById('questionInput');
        const question = questionInput.value.trim();
        
        if (!question) return;
        
        // 顯示用戶問題
        addMessage('user', question);
        questionInput.value = '';
        
        // 顯示加載中
        const loadingId = addMessage('assistant', '<div class="typing-indicator"><span></span><span></span><span></span></div>');
        
        // 發送問題到後端
        fetch('/ask', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ question: question }),
        })
        .then(response => response.json())
        .then(data => {
          // 移除加載中訊息
          removeMessage(loadingId);
          
          // 顯示 AI 回答
          addMessage('assistant', data.answer);
          
          // 自動滾動到最新消息
          scrollChatToBottom();
        })
        .catch(error => {
          // 移除加載中訊息
          removeMessage(loadingId);
          
          // 顯示錯誤訊息
          addMessage('system', '抱歉，發生錯誤。請稍後再試。');
          console.error('Error:', error);
        });
      });
      
      // 添加聊天訊息
      function addMessage(type, content) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}-message`;
        messageDiv.id = 'msg-' + Date.now();
        
        const messageContent = document.createElement('div');
        messageContent.className = 'message-content';
        
        // 處理多行內容
        const formattedContent = content.replace(/\n/g, '<br>');
        messageContent.innerHTML = `<p>${formattedContent}</p>`;
        
        messageDiv.appendChild(messageContent);
        chatMessages.appendChild(messageDiv);
        
        scrollChatToBottom();
        return messageDiv.id;
      }
      
      // 移除訊息
      function removeMessage(messageId) {
        const message = document.getElementById(messageId);
        if (message) {
          message.remove();
        }
      }
      
      // 滾動到聊天框底部
      function scrollChatToBottom() {
        const chatMessages = document.getElementById('chatMessages');
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      // 輔助函數 - 計算文字寬度
      function getTextWidth(text, element) {
        const canvas =
          getTextWidth.canvas ||
          (getTextWidth.canvas = document.createElement("canvas"));
        const context = canvas.getContext("2d");
        context.font = getComputedStyle(element).font;
        const metrics = context.measureText(text);
        return metrics.width;
      }

      // 添加新的 CSS
      const style = document.createElement("style");
      style.textContent = `
        #floating-hint {
          position: absolute;
          pointer-events: none;
          z-index: 1000;
        }
        #floating-hint .word-type {
          color: #3498db;
          font-weight: 600;
        }
        #floating-hint .word-meaning {
          color: #95a5a6;
        }
      `;
      document.head.appendChild(style);

      // 處理 HTML 特殊字元
      function escapeHtml(text) {
        return text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;")
          .replace(/\n/g, "<br>");
      }

      // 處理鍵盤事件
      document
        .getElementById("noteInput")
        .addEventListener("keydown", function (e) {
          // 如果有顯示 AI 建議且按下 Tab 鍵
          if (e.key === "Tab" && suggestionVisible) {
            e.preventDefault();
            // 接受 AI 建議
            acceptAISuggestion();
          }
          // 按下右方向鍵到文本末尾也可以接受建議
          else if (e.key === "ArrowRight" && suggestionVisible) {
            const cursorPos = this.selectionStart;
            if (cursorPos === this.value.length) {
              e.preventDefault();
              acceptAISuggestion();
            }
          }
          // 按下 Escape 鍵取消建議
          else if (e.key === "Escape" && suggestionVisible) {
            e.preventDefault();
            clearAISuggestion();
          }
        });

      // 接受 AI 建議
      function acceptAISuggestion() {
        if (!suggestionVisible || !currentAISuggestion) return;

        const noteInput = document.getElementById("noteInput");
        const originalText = noteInput.value;

        // 將建議添加到文本
        noteInput.value = originalText + currentAISuggestion;

        // 移動光標到文本末尾
        noteInput.setSelectionRange(
          noteInput.value.length,
          noteInput.value.length
        );

        // 清除建議
        clearAISuggestion();

        // 更新字數
        updateCharCount();

        // 觸發 input 事件，確保其他功能正常運行
        const inputEvent = new Event("input", { bubbles: true });
        noteInput.dispatchEvent(inputEvent);
      }
      // 格式化日期 YYYY-MM-DD
      function formatDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      }
      // 格式化單字建議，增強詞性和釋義的顯示
      function formatWordSuggestion(suggestion) {
        // 找出所有的詞性標記 [n.], [v.], [adj.] 等
        const parts = suggestion.split(/(\[\w+\.\])/g);
        if (parts.length > 1) {
          let formattedOutput = "";

          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (part.match(/^\[\w+\.\]$/)) {
              // 這是詞性標記
              formattedOutput += '<span class="word-type">' + part + "</span>";
            } else if (i > 0 && parts[i - 1].match(/^\[\w+\.\]$/)) {
              // 這是跟在詞性後面的釋義
              const meanings = part.split(/[;；]/); // 分號分隔不同詞性的解釋

              if (meanings.length > 1) {
                // 有多個詞性解釋
                formattedOutput +=
                  '<span class="word-meaning">' + meanings[0] + "</span>";

                for (let j = 1; j < meanings.length; j++) {
                  // 後續的詞性和解釋
                  const nextPart = parts[i + j * 2 - 1] || "";
                  const nextMeaning = meanings[j] || "";

                  formattedOutput +=
                    ';<span class="word-type">' +
                    nextPart +
                    "</span>" +
                    '<span class="word-meaning">' +
                    nextMeaning +
                    "</span>";
                }

                // 跳過已處理的詞性和解釋
                i += (meanings.length - 1) * 2;
              } else {
                // 單個詞性解釋
                formattedOutput +=
                  '<span class="word-meaning">' + part + "</span>";
              }
            } else {
              // 其他部分，例如單字本身
              formattedOutput += part;
            }
          }

          return formattedOutput;
        }

        return suggestion;
      }
      // 初始化時獲取最新的筆記版本
      fetchNotes();
    </script>
  </body>
</html>
